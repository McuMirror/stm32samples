 1. Непонимание что такое "атомарный доступ" и для чего нужно "volatile" при совместной работе разных процессов/ISR с одними данными.

Смотрим например на usart2_getline() вызывающуюся в фоне и usart2_isr() (видимо - ISR), и думаем что будет если прерывание usart2_isr() произойдёт между строкой

int L = linerdy;

и строкой

linerdy = 0;

 

2. Алгоритм работы с приёмным потоком UART - в корне ущербный. Достаточно подумать, что будет если на большой скорости UART два символа '\n' подряд и в это время фоновая задача будет занята какой-то более-менее длительной работой (а ведь мы знаем что автор сего - ненавистник РТОС, и у него не будет повышен приоритет задаче, разгребающей UART-RX поток ;).

 

3. Инициализация UART (usart2_setup()) - кривая. Сначала автор программирует DMA на работу с UART, включает его, и только затем включает тактирование UART и инициализирует его.

Также - мультиплексор пинов переключает ноги с GPIO на UART ещё до инициализации самого UART (глитчи обеспечены).

Правильный порядок: 1) инит DMA; 2) инит UART; 3) разрешение DMA; 4) разрешение прерываний; 5) переключение мультиплексора ног GPIO->UART. И не забывать использовать __DMB﻿() где надо.

 

4. Зачем в main() такое?:

const char dummy[] = "dummy text\n", err[] = "Error!\n";

Видимо чтобы получить как можно более тяжёлый код и занять побольше стека. Автор видимо не знает для чего нужно "static".  :unknw:

 

5. Автор не читает мануал на используемый МК. Если бы читал, не писал бы такое:

USART2_ICR |= USART_ISR_CMF; // clear flag

Читаем описание регистра USART2_ICR и думаем: Что будет с остальными флагами кроме CMF после такой операции? Да и вообще - зачем читать из регистра если для сброса флага нужна запись в него "1"??? Тема эта уже 100500 раз обсасывалась здесь на форуме.

То же самое здесь:

DMA1_IFCR |= DMA_IFCR_CIF4; // clear TC flag

и в других подобных местах. Регистр DMA1_IFCR - write-only! Опять же - RTFM.

Наверняка ещё куча подобных багов есть - смотрел по диагонали.

 

6. Исходник просто наполнен "магическими" числами - стиль программирования начинающего. Плохой стиль. ﻿
